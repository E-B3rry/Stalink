-- Load APIs and set constants --
os.unloadAPI("rednet")


-- Set local variables
local meetingChannel = 0
local meetingPrivateKey = nil

local connections = {}
local isAcceptingConnection = false

redComSides = {
  ["left"] = {},
  ["right"] = {},
  ["up"] = {},
  ["down"] = {},
  ["front"] = {},
  ["back"] = {}
}

-- Define functions
function receive()
  -- Pulling event from os queue (Using a specific way so that os.pullEvent doesn't block the program)
  timer = os.startTimer(0.05)
  local e, s, channel, replyChannel, msg, distance = os.pullEvent()

  --
  if e ~= "modem_message" and e ~= "timer" then
    -- Take actions to put back this damn event in the queue
    return nil
  elseif e == "timer" and s == timer then
    return nil
  elseif not isOpen(channel, s) then
    return nil
  end

  if isAcceptingConnection then
    if channel == meetingChannel then
      if not meetingPrivateKey then
        return "new_connection", channel, msg
      end
    end
  end

  return channel, msg, distance
end

function send(channel, msg, side)
  if side then
    if not isOpen(channel, side) then
      error("Channel " .. channel .. " not opened on side " .. side .. ".", 2)
    end
  else
    side = isOpen(channel)

    if not side then
      error("Channel " .. channel .. " not openend on any sides.", 2)
    end
  end

  peripheral.call(side, "transmit", channel, 0, msg)
end

function isOpen(channel, sides)
  if type(channel) ~= "number" then
    error("Channel argument must be a number.", 2)
  elseif channel < 1 or channel > 65535 then
    error("Channel out of range [1 - 65535], got " .. channel .. ".", 2)
  end

  if type(sides) == "string" then
    sides = {sides}
  elseif type(sides) ~= "table" then
    sides = {"left", "right", "up", "down", "front", "back"}
  end

  for i = 0, #sides do
    if redComSides[sides[i]] then
      for k, openedChannel in pairs(redComSides[sides[i]]) do
        if channel == openedChannel then
          return sides[i]
        end
      end
    end
  end

  return false
end

function getOpenableModemSide()
  for side, channels in pairs(redComSides) do
    if isSideOpenable(side) then
      return side
    end
  end

  return false
end

function isSideOpenable(side)
  if peripheral.getType(side) == "modem" then
    if #(redComSides[side]) < 128 then
      return true
    end
  end

  return false
end

function open(channels, side)
  local notSpecifiedSide = false

  if side then
    local t = peripheral.getType(side)
    if t == nil then
      error("No peripheral detected on side " .. side .. ".", 2)
    elseif t ~= "modem" then
      error("The peripheral connected to side " .. side .. " is not a modem.", 2)
    end

    if #(redComSides[side]) > 127 then
      error("The " .. side .. " modem cannot open another channel (128 already in use).", 2)
    end
  else
    side = getOpenableModemSide()
    notSpecifiedSide = true

    if not side then
      error("There aren't any modem connected to the computer that can open channel.", 2)
    end
  end

  if type(channels) == "number" then
    peripheral.call(side, "open", channels)
    table.insert(redComSides[side], channels)
  elseif type(channels) == "table" then
    for channel in channels do
      if not isOpen(channel) then
        __InternalFunction_Open__(channel, side)
      end
    end
  else
    error("Expected number or table of numbers for channels argument.", 2)
  end

  return true
end

function __InternalFunction_Open__(channel, side)
  if #(redComSides[side]) > 127 then
    if notSpecifiedSide then
      side = getOpenableModemSide()

      if not side then
        error("Couldn't open all channels because there aren't any modems connected to the computer that can open channel anymore. (All the modems have 128 channels in use)", 3)
      end
    else
      error("Couldn't open all channels because " .. side .. " modem cannot open another channel (128 already in use).", 3)
    end
  end

  peripheral.call(side, "open", channel)
  redComSides[side].insert(channel)
end

function openMeetingChannel(channel, privateKey)
  if isOpen(meetingChannel) then
    close(meetingChannel)
  end

  if privateKey then
    meetingPrivateKey = tostring(privateKey)
  else
    meetingPrivateKey = nil
  end

  open(channel)
  meetingChannel = channel
  isAcceptingConnection = true
end
