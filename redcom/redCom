-- COMPLETELY
-- UNSAFE
-- (FOR
-- NOW
-- AT
-- LEAST)

-- Load APIs and set constants --
os.unloadAPI("rednet")

-- Define constants
local __USABLE_RANGE__ = {0, 65535}

-- Set local variables (!!! Reworking)
local meetingChannel = 0 -- Being replaced by a list of listened channels
local meetingPrivateKey = nil

local channelsListened = {}
--- Table for each listened channels ---
-- First param is the channel
-- Second param is the private key

local tunnels = {}
local isAcceptingTunneling = false

local lastTunnelID = 0;

redComSides = {
    ["left"] = {},
    ["right"] = {},
    ["up"] = {},
    ["down"] = {},
    ["front"] = {},
    ["back"] = {}
}


-- Define functions


-- Receive function
function receive()
    channel, replyChannel, msg, distance = receiveRaw()

    if not msg then
        return nil
    end

    if msg[1] == 0 then
        return "UDP", replyChannel, msg, distance
    end

    -- Verify we're the targeted recipient
    if msg[2] ~= os.getComputerID() then
        return
    end

  -- Handle meeting channel
    if channel == meetingChannel then
        if msg[3] == 1 then
            -- Check if there is an encryption system
            if meetingPrivateKey then
              -- Will do it later because of flemme
              -- (And will check with like the some test bytes that the decryption worked)
              -- Maybe using CRC of the msg as the first bytes
            end

            if isAcceptingTunneling then
                workingChannel = getNextFreeChannel()

                newConnection = {
                    ["id"] = generateNewConnectionID(),
                    ["status"] = 0, -- 0 is pending, 1 is working
                    ["channel"] = workingChannel,
                    ["machine_id"] = msg[4],
                    ["machine_name"] = msg[5],
                    ["machine_type"] = msg[6]
                }
                --- What was received ---
                -- First param : 0 = Raw data, 1 = TCP data
                -- Second param : Unique recipient ID
                -- Third param : Package type (0 = Data, 1 = Synchronisation, 2 = SYN/ACK, 3 = Acknowledgement, 4 = Terminating)
                -- Fourth param : Unique sender ID
                -- Fifth param : Name of this machine
                -- Sixth param : Type of this machine

                open(workingChannel)

                table.insert(tunnels, newConnection)

                sendRaw(meetingChannel, workingChannel, {1, msg[4], 2, 1, machineName, machineType, workingChannel})
                -- First param : 0 = Raw data, 1 = TCP data
                -- Second param : Unique recipient ID
                -- Third param : Package type (0 = Message, 1 = Handshake, 2 = HandshakeAnswer, 3 = HandshakeConfirmation, 4 = Terminating)
                -- Fourth param : 0 = Connection refused, 1 = Connection allowed
                -- Fifth param : Name of this machine
                -- Sixth param : Type of this machine
                -- Seventh param : Channel for TCP tunnel
            else
                sendRaw(meetingChannel, meetingChannel, {1, msg[4], 2, 0, 0})
                -- First param : 0 = Raw data, 1 = TCP data
                -- Second param : Unique recipient ID
                -- Third param : Package type (0 = Message, 1 = Handshake, 2 = HandshakeAnswer, 3 = HandshakeConfirmation, 4 = Terminating)
                -- Fourth param : 0 = Connection refused, 1 = Connection allowed
                -- Fifth param : 0 = Not accepting connection, 1 = Overloaded, 2 = Don't like ya
            end
        end
    else
        --- What was received ---
        -- *First param : 0 = Raw data, 1 = TCP data
        -- *Second param : Unique recipient ID
        -- *Third param : Package type (0 = Message, 1 = Handshake, 2 = HandshakeAnswer, 3 = HandshakeConfirmation, 4 = Terminating)
        -- Fourth param : Message
        if msg[3] == 0 then
            -- Obtain connection ID
            sender = retrieveConnection(channel)

            return "TCP", sender["id"], msg[4], distance
        elseif msg[3] == 3 then
            -- Fuck it, rework this thing later cauz that's just confirmation
            sender, senderKey = retrieveConnection(channel)

            tunnels[senderKey]["status"] = 1
        elseif msg[3] == 4 then
            -- Needs a rework too to implement functionnalities, like connection history and banning
            sender, senderKey = retrieveConnection(channel)

            tunnels[senderKey] = nil
            return "TCP_Terminated", sender["id"], msg[4]
        end
      end
end

-- Raw receive function
function receiveRaw()
  -- Pulling event from os queue (Using a specific way so that os.pullEvent doesn't block the program)
  local timer = os.startTimer(0.15)
  local eventTable = table.pack(os.pullEvent())

  -- Verify that the event is related to receive() function
  if eventTable[1] ~= "modem_message" and eventTable[2] ~= timer then
    -- Take actions to put back the wrong event back in queue
    os.cancelTimer(timer)
    os.queueEvent(table.unpack(eventTable))
    return nil
  end

  if eventTable[1] == "timer" and eventTable[2] == timer then
    -- If the timer event is triggered, return nil
    return nil
  end

  --print("Message received!")

  -- Unpack all the arguments and work with them
  local e, s, channel, replyChannel, msg, distance = table.unpack(eventTable)
  --print("Channel : " .. tostring(channel))

  if msg then
    if type(msg) == "string" then
        --print("Message : " .. tostring(msg))
    else
      for key, item in pairs(msg) do
        print(tostring(key) .. " - " .. tostring(item))
      end
    end
  end

  -- If the receiving channel is not registered as opened on the receiving side then ignore
  if not isOpen(channel, s) then
    print("Blobby fucked up there")
    return nil
  end

  -- -- TCP like protocol handler
  -- if isAcceptingConnection then
  --   if channel == meetingChannel then
  --     if not meetingPrivateKey then
  --       return "new_connection", channel, msg
  --     end
  --   end
  -- end

  -- Simply returning the message

  msg = textutils.unserialize(msg)

  return channel, replyChannel, msg, distance
end

-- Send messages to established connections
function sendTCP(recipient, msg)

end

function sendUDP(port, msg)

end


-- Get the next available channel for tunneling
function getNextFreeChannel()
    -- Temporary; need a real system
    return math.random(__USABLE_RANGE__[1], __USABLE_RANGE__[2])
end


-- Get connection ID
function retrieveConnection(channel)
    for k, connection in pairs(tunnels) do
        if connection["channel"] == channel then
            return connection, k
        end
    end
end


-- Send raw data
function sendRaw(channel, replyChannel, msg, side)
  if not side then
    side = getWorkingModemSide()

    if not side then
      return false
    end
  end

  msg = textutils.serialize(msg)

  peripheral.call(side, "transmit", channel, replyChannel, msg)
  return true
end


function isOpen(channel, sides)
  if type(channel) ~= "number" then
    error("Channel argument must be a number.", 2)
  elseif channel < 0 or channel > 65535 then
    error("Channel out of range [0 - 65535], got " .. channel .. ".", 2)
  end

  if type(sides) == "string" then
    sides = {sides}
  elseif type(sides) ~= "table" then
    sides = {"left", "right", "up", "down", "front", "back"}
  end

  for i = 0, #sides do
    if redComSides[sides[i]] then
      for k, openedChannel in pairs(redComSides[sides[i]]) do
        if channel == openedChannel then
          return sides[i]
        end
      end
    end
  end

  return false
end


function getWorkingModemSide()
  for side, channels in pairs(redComSides) do
    if peripheral.getType(side) == "modem" then
      return side
    end
  end

  return false
end


function getOpenableModemSide()
  for side, channels in pairs(redComSides) do
    if isSideOpenable(side) then
      return side
    end
  end

  return false
end


function isSideOpenable(side)
  if peripheral.getType(side) == "modem" then
    if #(redComSides[side]) < 128 then
      return true
    end
  end

  return false
end


function open(channels, side)
    local notSpecifiedSide = false

    if side then
        local t = peripheral.getType(side)
        if t == nil then
          error("No peripheral detected on side " .. side .. ".", 2)
        elseif t ~= "modem" then
          error("The peripheral connected to side " .. side .. " is not a modem.", 2)
        end

        if #(redComSides[side]) > 127 then
          error("The " .. side .. " modem cannot open another channel (128 already in use).", 2)
        end
    else
        side = getOpenableModemSide()
        notSpecifiedSide = true

        if not side then
          error("There aren't any modem connected to the computer that can open channel.", 2)
        end
    end

    if type(channels) == "number" then
        peripheral.call(side, "open", channels)
        table.insert(redComSides[side], channels)
    elseif type(channels) == "table" then
        for channel in channels do
            if not isOpen(channel) then
                open__InternalFunction_Open__(channel, side)
            end
        end
    else
        error("Expected number or table of numbers for channels argument.", 2)
    end

    return true
end

function close(channels)
    if type(channels) == "number" then
        side = isOpen(channels)
        if side then
            peripheral.call(side, "close", channels)
            for i = 0, #(redComSides[side]) do
                if redComSides[side][i] == channels then
                    table.remove(redComSides[side], i)
                    break
                end
            end
        end
    elseif type(channels) == "table" then
        for channel in channels do
            side = isOpen(channel)
            if side then
                peripheral.call(side, "close", channel)
                for i = 0, #(redComSides[side]) do
                    if redComSides[side][i] == channel then
                        table.remove(redComSides[side], i)
                        break
                    end
                end
            end
        end
    else
        error("Expected number or table of numbers for channels argument.", 2)
    end

    return true
end

function open__InternalFunction_Open__(channel, side)
  if #(redComSides[side]) > 127 then
    if notSpecifiedSide then
      side = getOpenableModemSide()

      if not side then
        error("Couldn't open all channels because there aren't any modems connected to the computer that can open channel anymore. (All the modems have 128 channels in use)", 3)
      end
    else
      error("Couldn't open all channels because " .. side .. " modem cannot open another channel (128 already in use).", 3)
    end
  end

  peripheral.call(side, "open", channel)
  redComSides[side].insert(channel)
end

function generateNewConnectionID()
    last = lastTunnelID
    lastTunnelID = lastTunnelID + 1
    return last
end

--- Reworking this, prone to disappear

function openMeetingChannel(channel, privateKey)
  if isOpen(meetingChannel) then
    close(meetingChannel)
  end

  if privateKey then
    meetingPrivateKey = tostring(privateKey)
  else
    meetingPrivateKey = nil
  end

  open(channel)
  meetingChannel = channel
  isAcceptingTunneling = true
end

print("RedCom API Loaded")

function closeMeetingChannel()
  if isOpen(meetingChannel) then
    close(meetingChannel)
  end

  meetingPrivateKey = nil
  meetingChannel = nil
  isAcceptingTunneling = false
end
